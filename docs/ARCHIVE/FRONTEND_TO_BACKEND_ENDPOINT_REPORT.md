# Frontend → Backend: Endpoint Report (after frontend optimizations)

Дата: 2025-12-30

Формат: 
- ❗ endpoint: `/api/...`
- проблема: ...
- пропозиція: ...

## Часті виклики / ризик дублювання

- ❗ endpoint: `/api/v1/pages/products`
  - проблема: викликається з кількох місць (сторінка Products, пошук). На фронті включені фільтри/пагінація, тому при активній взаємодії користувача (фільтри/пошук) можливі часті запити.
  - пропозиція:
    - додати серверне кешування (наприклад, 30–60с) для однакових query params
    - переконатись, що відповідь підтримує пагінацію `page/limit` завжди та повертає `meta` стабільного формату
    - якщо `facets` важкі — повертати їх опційно (наприклад `includeFacets=1`) або окремим endpoint

- ❗ endpoint: `/api/v1/pages/stores`
  - проблема: аналогічно до products — при пошуку по магазинах параметр `search` може часто змінюватись.
  - пропозиція:
    - серверне кешування на короткий час
    - уніфікувати `meta` (page/limit/totalItems/totalPages/hasNext/hasPrev)

## Великий payload / overfetch

- ❗ endpoint: `/api/v1/items` (використовується як fallback та в деяких хуках списків)
  - проблема: у фронті є сценарії, де запитується великий ліміт (наприклад `limit=100`) або повний список без строгих полів → потенційний overfetch.
  - пропозиція:
    - додати/посилити пагінацію на сервері
    - додати параметр `fields=` або lightweight-режим для карток (тільки id/name/price/image/brand/category)
    - гарантувати, що `items` завжди повертається як масив + `meta`

- ❗ endpoint: `/api/v1/items/:id` та `/api/v1/items/:id/stores`
  - проблема: деталі продукту можуть тягнути багато вкладених даних. `stores` для продукту потенційно важкі (ціни/контакти/ознаки recommended тощо).
  - пропозиція:
    - якщо потрібно — додати серверну пагінацію/ліміт для `stores` або `includeStores=1`
    - прибрати з payload зайві поля, які не використовуються в UI

## Дублювання інформації / потреба BFF

- ❗ endpoint: `/api/v1/pages/product/:id`
  - проблема: при відсутності або деградації BFF фронт змушений робити кілька викликів (`/items/:id`, `/items/:id/stores`, `/brands/:id`).
  - пропозиція:
    - зробити цей endpoint канонічним і повним: `{ item: { product, stores, brand, relatedProducts } }`
    - додати серверне кешування для product detail (короткий TTL)

- ❗ endpoint: `/api/v1/pages/home`
  - проблема: у разі фейлу BFF фронт падає на кілька legacy endpoint-ів (`/api/items?limit=6`, `/api/statistics`).
  - пропозиція:
    - стабілізувати `/pages/home` як єдине джерело істини
    - прибрати тексти/локалізовані рядки з відповіді (див. i18n нижче)

- ❗ endpoint: `/api/v1/admin/dashboard`
  - проблема: якщо payload містить повні сутності (products/stores/brands) без лімітів — може бути важким для адмінки.
  - пропозиція:
    - забезпечити `items + meta` для кожної секції та обмежувати дефолтний `limit`
    - додати lightweight поля для списків

## i18n (бекенд не має віддавати UI-тексти)

- ❗ endpoint: *будь-які, які повертають локалізовані UI-поля*
  - проблема: UI рядки мають бути у фронтенд-словниках. Якщо бекенд повертає локалізовані тексти для UI, це дублює i18n.
  - пропозиція:
    - повертати тільки дані/коди (наприклад category/type/gender як enum), а текстові лейбли формувати на фронті через i18n

---

Якщо треба, я можу додати конкретні приклади payload-ів (до/після) з DevTools Network і виписати точні поля для `fields=`.
